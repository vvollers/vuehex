import { Meta, Canvas } from '@storybook/addon-docs/blocks';
import * as VueHexStories from "./VueHex.stories";

<Meta of={VueHexStories} title="Components/VueHex/Guides" />

# VueHex usage guide

These notes expand on each demo so newcomers can understand when to pick a
particular mode, which events fire, and how to customize the component without
inspecting the source.

## Virtual data contract

VueHex renders only a small window of a backing file. As you scroll, it emits
`updateVirtualData`, giving you the byte range it needs next so you can load data
from disk, HTTP ranges, or IndexedDB.

```ts
import type { VueHexWindowRequest } from "vuehex";

type VueHexWindowRequest = {
  offset: number; // starting byte index
  length: number; // preferred chunk length, used as a hint
};
```

### Typical integration

```ts
<template>
  <VueHex
    :bytes-per-row="16"
    :overscan="4"
    v-model="windowData"
    data-mode="window"
    :window-offset="windowOffset"
    :total-size="fileSize"
    :get-selection-data="getSelectionData"
    @updateVirtualData="handleUpdateVirtualData"
  />
</template>

<script setup lang="ts">
const windowData = ref(new Uint8Array());
const windowOffset = ref(0);

function handleUpdateVirtualData(payload: VueHexWindowRequest) {
  windowOffset.value = payload.offset;
  windowData.value = readBytes(payload.offset, payload.length ?? 0x4000);
}

function getSelectionData(selectionStart: number, selectionEnd: number) {
  const from = Math.min(selectionStart, selectionEnd);
  const to = Math.max(selectionStart, selectionEnd);
  return readBytes(from, to - from + 1);
}
</script>
```

Notes:

- Always provide `total-size` (or `:total-size` in Vue) even when streaming from a socket; VueHex uses it to size the scroll rails.
- When using `updateVirtualData`, also provide `getSelectionData` so selection/copy can fetch bytes outside the current window.
- You may debounce expensive fetches, but resolve them in order so a slower response cannot overwrite a newer one.
- Reuse buffers inside `windowData` when possible to reduce garbage collection pressure; the story keeps things explicit for clarity.

<Canvas of={VueHexStories.VirtualBinding} />

## Self-managed dataset

When you already own the entire `Uint8Array` (dropped file, clipboard paste, fixture), set `data-mode="buffer"` (or leave it as `auto` and provide the full buffer at `window-offset=0`). VueHex slices the full array internally while still virtualizing rows.

```vue
<template>
  <VueHex v-model="fullData" :bytes-per-row="24" />
</template>

<script setup lang="ts">
const fullData = ref(await file.arrayBuffer().then((buf) => new Uint8Array(buf)));
</script>
```

Behavior highlights:

- Buffer mode is explicit via `data-mode="buffer"` (recommended for clarity).
- You can continue mutating `fullData.value` to show highlights or edits; VueHex re-renders the affected rows.
- To use an external provider, set `data-mode="window"` and provide `total-size` + an `updateVirtualData` handler.

<Canvas of={VueHexStories.SelfManagedDataset} />

## Chunk navigator + linked hover

Use the chunk navigator when browsing multi-megabyte buffers and mirror hover
state into status bars or other panes.

```ts
type HoverPayload = { index: number };
// Events: "hex-hover-on", "hex-hover-off", "ascii-hover-on", "ascii-hover-off"
// "*-on" events emit HoverPayload; "*-off" events do not include data.
```

```vue
<VueHex
  :show-chunk-navigator="true"
  chunk-navigator-placement="left"
  :cell-class-for-byte="cellClassForByte"
  v-model="windowData"
  data-mode="window"
  :window-offset="windowOffset"
  :total-size="totalBytes"
  @hex-hover-on="handleHover"
  @hex-hover-off="clearHover"
  @ascii-hover-on="handleHover"
  @ascii-hover-off="clearHover"
  @updateVirtualData="handleUpdateVirtualData"
/>
```

Tips:

- `total-size` alone is enough for proportional chunk bars, but setting `showChunkNavigator` makes your intent explicit.
- Return any class name from `cellClassForByte` to highlight ranges, search hits, or diffs.
- `cellClassForByte` can also be an array of resolvers, allowing you to layer multiple rules without re-implementing existing ones.
- Hover payloads are absolute file offsets, so consumers never have to add the current `windowOffset`.

### Layered highlighting

VueHex ships with a default ASCII category highlighter (digits/uppercase/lowercase/null) that is used when you omit `cellClassForByte`.
When you want to keep those defaults *and* add your own rules, pass an array:

```ts
import {
  DEFAULT_ASCII_CATEGORY_CELL_CLASS_RESOLVER,
  type VueHexCellClassResolver,
} from "vuehex";

const customHighlight: VueHexCellClassResolver = ({ index }) =>
  index % 16 === 0 ? "my-row-start" : undefined;

const cellClassForByte = [
  DEFAULT_ASCII_CATEGORY_CELL_CLASS_RESOLVER,
  customHighlight,
];
```

To disable all highlighting (including the defaults), pass `null`.

<Canvas of={VueHexStories.ChunkNavigatorHover} />

## ASCII printability presets

`isPrintable` decides whether a byte renders as a character or falls back to the
`nonPrintableChar`. Import `VUE_HEX_ASCII_PRESETS` to skip reimplementing common
ranges and pair them with their matching `renderAscii` helpers.

```ts
import { VUE_HEX_ASCII_PRESETS } from "vuehex";

const presetKey = ref<"standard" | "latin1" | "visibleWhitespace">("standard");
const activePreset = computed(() => VUE_HEX_ASCII_PRESETS[presetKey.value]);
```

Supported bundles:

- **standard** -- ASCII 0x20-0x7E.
- **latin1** -- ASCII plus Latin-1 supplement (0xA0-0xFF).
- **visibleWhitespace** -- ASCII plus custom glyphs for tab, newline, carriage return, and space.

Apply them directly:

```vue
<VueHex
  v-model="windowData"
  :window-offset="windowOffset"
  :total-size="fileSize"
  :is-printable="activePreset.isPrintable"
  :render-ascii="activePreset.renderAscii"
/>
```

<Canvas of={VueHexStories.AsciiPrintablePresets} />

## Built-in themes

The component ships with four palettes so you can pick a vibe without defining a
token sheet. Themes are pure CSS, so switching between them does not trigger
re-computation inside VueHex. Override individual custom properties (such as
`--vuehex-byte-color`) when you only need slight tweaks.

When you omit the `theme` prop, VueHex automatically chooses between the dark
and light palettes using `prefers-color-scheme`, so your app matches the
visitor's OS preference with zero extra code.

### Dark Mode

Perfect for long debugging sessions with high contrast.

<Canvas of={VueHexStories.ThemeDark} />

### Light Mode

Soft neutrals that blend into docs or wikis.

<Canvas of={VueHexStories.ThemeLight} />

### Terminal

Retro CRT greens for command-line nostalgia.

<Canvas of={VueHexStories.ThemeTerminal} />

### Sunset

A playful gradient backdrop with warm highlights.

<Canvas of={VueHexStories.ThemeSunset} />

## Status bar layout

When `statusbar` is set to `"top"` or `"bottom"`, you can choose where each
status bar item renders by providing `statusbarLayout`. The status bar is split
into three sections:

- `left` (left-aligned)
- `middle` (centered)
- `right` (right-aligned)

Each section is an array of **status bar components**:

```ts
import type { VueHexStatusBarLayout } from "vuehex";

const layout: VueHexStatusBarLayout = {
  left: ["offset", "hex"],
  middle: ["ascii"],
  right: ["selection"],
};
```

Components can be provided as strings (component name) or as objects when you
also want to attach configuration:

```ts
const layout: VueHexStatusBarLayout = {
  left: [
    { name: "offset", config: { format: "hex", pad: 8 } },
    { name: "hex", config: { prefix: true } },
  ],
  middle: [{ name: "ascii", config: { quote: true } }],
  right: [
    { name: "selection", config: { label: "Sel", showWhenEmpty: false } },
  ],
};
```

Built-in component names:

- `offset`
- `hex`
- `ascii`
- `selection`
- `slot`

Notes:

- Unknown component names are ignored.
- When omitted, `statusbarLayout` defaults to `left: ["offset", "hex", "ascii"], right: ["selection"]`.

### Custom slot components

Use the built-in `slot` component name to render your own custom content inside the status bar.

VueHex exposes three named slots:

- `#statusbar-left`
- `#statusbar-middle`
- `#statusbar-right`

To control where your slot content appears relative to built-in items, place `"slot"` in the corresponding `statusbarLayout` section:

```vue
<VueHex
  statusbar="bottom"
  :statusbar-layout="{ left: ['offset', 'slot', 'hex'], middle: ['ascii'], right: ['selection'] }"
  v-model="data"
>
  <template #statusbar-left>
    <span>Mode: RO</span>
  </template>
</VueHex>
```

### Label configuration

All built-in status bar components support overriding their label text via
`config.label`:

```ts
const layout: VueHexStatusBarLayout = {
  left: [
    { name: "offset", config: { label: "Addr" } },
    { name: "hex", config: { label: "Byte" } },
    { name: "ascii", config: { label: "Char" } },
  ],
  right: [{ name: "selection", config: { label: "Sel" } }],
};
```

### Supported config keys

- Common: `label`, `valueMinWidth` (CSS length), `valueWidth` (CSS length)
- `offset`: `format` ("hex"), `pad` (number), `prefix` (boolean)
- `hex`: `prefix` (boolean)
- `ascii`: `quote` (boolean)
- `selection`: `showWhenEmpty` (boolean)

## Cursor

Enable the optional cursor to move around the dataset with the keyboard.

- Set the boolean `cursor` prop to enable the feature.
- Press arrow keys while the viewer is focused to move the cursor.
- Click any hex/ASCII byte to set the cursor.
- Use `cursorLocation` (and `update:cursorLocation`) to control the location from the parent.
- Listen to `cursor-change` to react when the cursor moves.

```vue
<template>
  <VueHex
    v-model="data"
    cursor
    v-model:cursorLocation="cursorLocation"
    style="height: 320px"
    @cursor-change="({ index }) => console.log('cursor moved', index)"
  />
</template>

<script setup lang="ts">
import { ref } from "vue";
import VueHex from "vuehex";

const data = ref(new Uint8Array(1024));
const cursorLocation = ref<number | null>(0);
</script>
```

<Canvas of={VueHexStories.Cursor} />

## Custom themes

Target the emitted `.vuehex-theme-<token>` selector to ship your own art
direction. Attach a stylesheet near the story/component and redefine the CSS
custom properties VueHex consumes.

```ts
<template>
  <VueHex theme="storybook-custom" v-model="windowData" />
</template>

<style scoped src="./vuehex-custom-theme.css"></style>
```

Available CSS variables:

- `--vuehex-background`, `--vuehex-foreground`, `--vuehex-border-color`
- `--vuehex-offset-color`, `--vuehex-offset-leading-opacity`
- `--vuehex-row-divider`, `--vuehex-byte-color`
- `--vuehex-ascii-color`, `--vuehex-ascii-non-printable-color`
- `--vuehex-ascii-column-border`, `--vuehex-mid-column-gutter`

Structural selectors you can target:

```css
.vuehex-theme-your-token .vuehex-byte { /* hex column cells */ }
.vuehex-theme-your-token .vuehex-ascii-char { /* ASCII column */ }
.vuehex-theme-your-token .vuehex-byte.vuehex-linked-hover { /* shared hover */ }
.vuehex-theme-your-token .vuehex-ascii-char.vuehex-linked-hover { /* ASCII hover */ }
```

Pair those hooks with gradients, shadows, or data-URI textures to match your
brand. Because themes are only CSS, no recompilation is necessary--just load the
stylesheet next to your component.

<Canvas of={VueHexStories.CustomTheme} />
