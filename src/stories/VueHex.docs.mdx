import { Meta, Canvas } from '@storybook/addon-docs/blocks';
import * as VueHexStories from "./VueHex.stories";

<Meta of={VueHexStories} title="Components/VueHex/Guides" />

# VueHex

VueHex is a fast, virtualized hex viewer component for Vue 3. It can be used both for cleanly displaying binary data and for efficiently viewing very large datasets.

**Key features:**
* No dependencies
* Small package (~64KB minimized / ~15KB zipped)
* Render local and remote data
* Can handle extremely large data sizes (terabytes with virtual data mode)
* Very flexible and themeable
* Keyboard navigation and selection support

## Quick Start

```vue
<template>
  <VueHex
    v-model="windowData"
  />
</template>

<script setup lang="ts">
import { ref } from "vue";
import VueHex from "vuehex";

const windowData = ref(new Uint8Array());

function loadWindow({ offset, length }) {
  // Load bytes from your data source
  windowData.value = fetchBytes(offset, length);
}
</script>
```

## Props

<table>
  <thead>
    <tr>
      <th>Prop</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>modelValue</code></td>
      <td><strong>required</strong></td>
      <td>The currently visible <code>Uint8Array</code>. Use with <code>v-model</code>.</td>
    </tr>
    <tr>
      <td><code>dataMode</code></td>
      <td><code>auto</code></td>
      <td>Data handling mode: <code>auto</code>, <code>buffer</code>, or <code>window</code>.</td>
    </tr>
    <tr>
      <td><code>expandToContent</code></td>
      <td><code>false</code></td>
      <td>Disables internal scrolling/virtualization and expands to fit full buffer.</td>
    </tr>
    <tr>
      <td><code>windowOffset</code></td>
      <td><code>0</code></td>
      <td>Absolute start offset represented by <code>modelValue</code>. Supports <code>v-model:window-offset</code>.</td>
    </tr>
    <tr>
      <td><code>totalSize</code></td>
      <td><code>modelValue.length</code></td>
      <td>Total bytes available.</td>
    </tr>
    <tr>
      <td><code>bytesPerRow</code></td>
      <td><code>16</code></td>
      <td>Number of bytes to display per row.</td>
    </tr>
    <tr>
      <td><code>uppercase</code></td>
      <td><code>false</code></td>
      <td>Whether to display hex values in uppercase.</td>
    </tr>
    <tr>
      <td><code>nonPrintableChar</code></td>
      <td><code>'.'</code></td>
      <td>Character to display for non-printable bytes in ASCII column.</td>
    </tr>
    <tr>
      <td><code>isPrintable</code></td>
      <td>—</td>
      <td>Function to customize ASCII printability check.</td>
    </tr>
    <tr>
      <td><code>renderAscii</code></td>
      <td>—</td>
      <td>Function to customize ASCII character rendering.</td>
    </tr>
    <tr>
      <td><code>theme</code></td>
      <td>—</td>
      <td>Color theme: <code>'auto'</code>, <code>'light'</code>, <code>'dark'</code>, <code>'terminal'</code>, <code>'sunset'</code>, or any custom token (emits <code>.vuehex-theme-&lt;token&gt;</code>).</td>
    </tr>
    <tr>
      <td><code>cellClassForByte</code></td>
      <td>—</td>
      <td>Function or array of functions for custom byte highlighting.</td>
    </tr>
    <tr>
      <td><code>getSelectionData</code></td>
      <td>—</td>
      <td>Function <code>(start, end) =&gt; Uint8Array</code> for clipboard copy support.</td>
    </tr>
    <tr>
      <td><code>overscan</code></td>
      <td><code>2</code></td>
      <td>Number of extra rows to render above and below viewport.</td>
    </tr>
    <tr>
      <td><code>showChunkNavigator</code></td>
      <td><code>false</code></td>
      <td>Enable the chunk navigator UI for large datasets.</td>
    </tr>
    <tr>
      <td><code>chunkNavigatorPlacement</code></td>
      <td><code>'right'</code></td>
      <td>Placement: <code>'left'</code>, <code>'right'</code>, <code>'top'</code>, or <code>'bottom'</code>.</td>
    </tr>
    <tr>
      <td><code>statusbar</code></td>
      <td><code>null</code></td>
      <td>Status bar placement: <code>'top'</code>, <code>'bottom'</code>, or <code>null</code>.</td>
    </tr>
    <tr>
      <td><code>statusbarLayout</code></td>
      <td>—</td>
      <td>Configuration for status bar item placement.</td>
    </tr>
    <tr>
      <td><code>cursor</code></td>
      <td><code>false</code></td>
      <td>Enable keyboard cursor navigation.</td>
    </tr>
    <tr>
      <td><code>editable</code></td>
      <td><code>false</code></td>
      <td>Enable editor mode (typing/paste emits <code>edit</code> intents). Cursor is automatically enabled while editing.</td>
    </tr>
    <tr>
      <td><code>cursorLocation</code></td>
      <td><code>null</code></td>
      <td>Controlled cursor location. Supports <code>v-model:cursorLocation</code>.</td>
    </tr>
  </tbody>
</table>

## Models

VueHex uses Vue 3's <code>defineModel</code> for two-way data binding. These support <code>v-model</code> syntax:

<table>
  <thead>
    <tr>
      <th>Model</th>
      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>v-model</code></td>
      <td><code>Uint8Array</code></td>
      <td><code>new Uint8Array(0)</code></td>
      <td>The currently visible data buffer. In buffer mode, this is the entire dataset; in window mode, this is the current slice.</td>
    </tr>
    <tr>
      <td><code>v-model:windowOffset</code></td>
      <td><code>number</code></td>
      <td><code>0</code></td>
      <td>Absolute byte offset of the current window. Automatically updates when scrolling, and scrolls the viewer when changed externally.</td>
    </tr>
    <tr>
      <td><code>v-model:cursorLocation</code></td>
      <td><code>number | null</code></td>
      <td><code>null</code></td>
      <td>Current cursor position (absolute byte index). Only active when <code>cursor</code> prop is <code>true</code>. Automatically updates when navigating.</td>
    </tr>
  </tbody>
</table>

## Events

<table>
  <thead>
    <tr>
      <th>Event</th>
      <th>Payload</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>updateVirtualData</code></td>
      <td><code>&#123; offset: number, length: number &#125;</code></td>
      <td>Emitted when the component needs more data in windowed mode.</td>
    </tr>
    <tr>
      <td><code>edit</code></td>
      <td><code>VueHexEditIntent</code></td>
      <td>Emitted when <code>editable</code> is enabled and the user types, deletes, pastes, or cuts.</td>
    </tr>
    <tr>
      <td><code>byte-click</code></td>
      <td><code>&#123; index: number, byte: number, kind: 'hex' | 'ascii' &#125;</code></td>
      <td>Emitted when a byte cell is clicked.</td>
    </tr>
    <tr>
      <td><code>selection-change</code></td>
      <td><code>&#123; start: number | null, end: number | null, length: number &#125;</code></td>
      <td>Emitted when the selection changes.</td>
    </tr>
    <tr>
      <td><code>row-hover-on</code> / <code>row-hover-off</code></td>
      <td><code>&#123; offset: number &#125;</code></td>
      <td>Emitted when hovering over/leaving a row.</td>
    </tr>
    <tr>
      <td><code>hex-hover-on</code> / <code>hex-hover-off</code></td>
      <td><code>&#123; index: number, byte: number &#125;</code></td>
      <td>Emitted when hovering over/leaving a hex cell.</td>
    </tr>
    <tr>
      <td><code>ascii-hover-on</code> / <code>ascii-hover-off</code></td>
      <td><code>&#123; index: number, byte: number &#125;</code></td>
      <td>Emitted when hovering over/leaving an ASCII cell.</td>
    </tr>
  </tbody>
</table>

## Usage Patterns

The following sections demonstrate common usage patterns and features. Each example includes working code you can adapt for your needs.

## Virtual data contract

VueHex renders only a small window of a backing file. As you scroll, it emits
`updateVirtualData`, giving you the byte range it needs next so you can load data
from disk, HTTP ranges, or IndexedDB.

```ts
import type { VueHexWindowRequest } from "vuehex";

type VueHexWindowRequest = {
  offset: number; // starting byte index
  length: number; // preferred chunk length, used as a hint
};
```

### Typical integration

```ts
<template>
  <VueHex
    :bytes-per-row="16"
    :overscan="4"
    v-model="windowData"
    data-mode="window"
    :window-offset="windowOffset"
    :total-size="fileSize"
    :get-selection-data="getSelectionData"
    @updateVirtualData="handleUpdateVirtualData"
  />
</template>

<script setup lang="ts">
const windowData = ref(new Uint8Array());
const windowOffset = ref(0);

function handleUpdateVirtualData(payload: VueHexWindowRequest) {
  windowOffset.value = payload.offset;
  windowData.value = readBytes(payload.offset, payload.length ?? 0x4000);
}

function getSelectionData(selectionStart: number, selectionEnd: number) {
  const from = Math.min(selectionStart, selectionEnd);
  const to = Math.max(selectionStart, selectionEnd);
  return readBytes(from, to - from + 1);
}
</script>
```

Notes:

- Always provide `total-size` (or `:total-size` in Vue) even when streaming from a socket; VueHex uses it to size the scroll rails.
- When using `updateVirtualData`, also provide `getSelectionData` so selection/copy can fetch bytes outside the current window.
- You may debounce expensive fetches, but resolve them in order so a slower response cannot overwrite a newer one.
- Reuse buffers inside `windowData` when possible to reduce garbage collection pressure; the story keeps things explicit for clarity.

<Canvas of={VueHexStories.VirtualBinding} />

## Self-managed dataset

When you already own the entire `Uint8Array` (dropped file, clipboard paste, fixture), set `data-mode="buffer"` (or leave it as `auto` and provide the full buffer at `window-offset=0`). VueHex slices the full array internally while still virtualizing rows.

```vue
<template>
  <VueHex v-model="fullData" :bytes-per-row="24" />
</template>

<script setup lang="ts">
const fullData = ref(await file.arrayBuffer().then((buf) => new Uint8Array(buf)));
</script>
```

Behavior highlights:

- Buffer mode is explicit via `data-mode="buffer"` (recommended for clarity).
- You can continue mutating `fullData.value` to show highlights or edits; VueHex re-renders the affected rows.
- To use an external provider, set `data-mode="window"` and provide `total-size` + an `updateVirtualData` handler.

<Canvas of={VueHexStories.SelfManagedDataset} />

## Editable mode (hex editor)

Turn the viewer into an editor by setting the <code>editable</code> prop. VueHex will accept keyboard input (when focused) and emit a single <code>edit</code> event describing what the user is trying to do.

### Interaction model

- **Active column**: click in the hex or ASCII column to choose which column you are editing; press <code>Tab</code> to toggle.
- **Insert vs overwrite**: overwrite is the default; press <code>Insert</code> to toggle insert mode.
- **Hex typing**: two nibbles commit a byte (e.g. <code>A</code> then <code>F</code> writes <code>0xAF</code>). Moving the cursor clears any half-entered nibble.
- **Selection**: click-drag selects bytes; typing/paste replaces the selection; <code>Delete</code>/<code>Backspace</code> deletes the selection.
- **Clipboard**:
  - <code>Ctrl/Cmd+C</code> copies selection (hex selection copies space-separated hex bytes; ASCII copies characters)
  - <code>Ctrl/Cmd+V</code> pastes
    - in **hex column**: clipboard is treated as hex data; whitespace is ignored
    - in **ASCII column**: clipboard is pasted as text (bytes are clamped to 0–255)
  - <code>Ctrl/Cmd+X</code> cuts selection (copy + delete)
- **Undo/redo**:
  - <code>Ctrl/Cmd+Z</code> undo
  - <code>Ctrl/Cmd+Y</code> redo (also <code>Ctrl/Cmd+Shift+Z</code>)

### Buffer mode (self-managed)

In <code>data-mode=&quot;buffer&quot;</code>, VueHex can apply edits to <code>v-model</code> automatically. Listening to <code>@edit</code> is optional (useful for undo/redo, persistence, telemetry).

<Canvas of={VueHexStories.Editable} />

### Window mode (parent-managed)

In <code>data-mode=&quot;window&quot;</code>, VueHex does not own the full dataset.

You should:

- Handle <code>@updateVirtualData</code> to load the requested window into <code>v-model</code>
- Provide <code>getSelectionData</code> so copy/cut can fetch bytes outside the current window
- Handle <code>@edit</code> by applying the intent to your backing store and then refreshing <code>v-model</code> (and <code>total-size</code>)

The intent is designed to be simple to apply:

```ts
import type { VueHexEditIntent } from "vuehex";

// Applies the intent to your backing bytes. You may clamp, reject, or normalize
// intents depending on your use case (fixed-size files vs growable buffers).
function applyEditIntent(bytes: Uint8Array, intent: VueHexEditIntent): Uint8Array {
  switch (intent.kind) {
    case "overwrite-byte":
    case "insert-byte":
    case "overwrite-bytes":
    case "insert-bytes":
    case "delete-byte":
    case "delete-range":
    case "undo":
    case "redo":
      // See the "Editable (windowed)" story for a complete implementation.
      return bytes;
  }
}
```

<Canvas of={VueHexStories.EditableWindowed} />

## Chunk navigator + linked hover

Use the chunk navigator when browsing multi-megabyte buffers and mirror hover
state into status bars or other panes.

```ts
type HoverPayload = { index: number };
// Events: "hex-hover-on", "hex-hover-off", "ascii-hover-on", "ascii-hover-off"
// "*-on" events emit HoverPayload; "*-off" events do not include data.
```

```vue
<VueHex
  :show-chunk-navigator="true"
  chunk-navigator-placement="left"
  :cell-class-for-byte="cellClassForByte"
  v-model="windowData"
  data-mode="window"
  :window-offset="windowOffset"
  :total-size="totalBytes"
  @hex-hover-on="handleHover"
  @hex-hover-off="clearHover"
  @ascii-hover-on="handleHover"
  @ascii-hover-off="clearHover"
  @updateVirtualData="handleUpdateVirtualData"
/>
```

Tips:

- `total-size` alone is enough for proportional chunk bars, but setting `showChunkNavigator` makes your intent explicit.
- Return any class name from `cellClassForByte` to highlight ranges, search hits, or diffs.
- `cellClassForByte` can also be an array of resolvers, allowing you to layer multiple rules without re-implementing existing ones.
- Hover payloads are absolute file offsets, so consumers never have to add the current `windowOffset`.

### Layered highlighting

VueHex ships with a default ASCII category highlighter (digits/uppercase/lowercase/null) that is used when you omit `cellClassForByte`.
When you want to keep those defaults *and* add your own rules, pass an array:

```ts
import {
  DEFAULT_ASCII_CATEGORY_CELL_CLASS_RESOLVER,
  type VueHexCellClassResolver,
} from "vuehex";

const customHighlight: VueHexCellClassResolver = ({ index }) =>
  index % 16 === 0 ? "my-row-start" : undefined;

const cellClassForByte = [
  DEFAULT_ASCII_CATEGORY_CELL_CLASS_RESOLVER,
  customHighlight,
];
```

To disable all highlighting (including the defaults), pass `null`.

<Canvas of={VueHexStories.ChunkNavigatorHover} />

## ASCII printability presets

`isPrintable` decides whether a byte renders as a character or falls back to the
`nonPrintableChar`. Import `VUE_HEX_ASCII_PRESETS` to skip reimplementing common
ranges and pair them with their matching `renderAscii` helpers.

```ts
import { VUE_HEX_ASCII_PRESETS } from "vuehex";

const presetKey = ref<"standard" | "latin1" | "visibleWhitespace">("standard");
const activePreset = computed(() => VUE_HEX_ASCII_PRESETS[presetKey.value]);
```

Supported bundles:

- **standard** -- ASCII 0x20-0x7E.
- **latin1** -- ASCII plus Latin-1 supplement (0xA0-0xFF).
- **visibleWhitespace** -- ASCII plus custom glyphs for tab, newline, carriage return, and space.

Apply them directly:

```vue
<VueHex
  v-model="windowData"
  :window-offset="windowOffset"
  :total-size="fileSize"
  :is-printable="activePreset.isPrintable"
  :render-ascii="activePreset.renderAscii"
/>
```

<Canvas of={VueHexStories.AsciiPrintablePresets} />

## Built-in themes

The component ships with five palettes so you can pick a vibe without defining a
token sheet. Themes are pure CSS, so switching between them does not trigger
re-computation inside VueHex. Override individual custom properties (such as
`--vuehex-byte-color`) when you only need slight tweaks.

When you omit the `theme` prop, VueHex automatically chooses between the dark
and light palettes using `prefers-color-scheme`, so your app matches the
visitor's OS preference with zero extra code.

### Dark Mode

Perfect for long debugging sessions with high contrast.

<Canvas of={VueHexStories.ThemeDark} />

### Light Mode

Soft neutrals that blend into docs or wikis.

<Canvas of={VueHexStories.ThemeLight} />

### Terminal

Retro CRT greens for command-line nostalgia.

<Canvas of={VueHexStories.ThemeTerminal} />

### Sunset

A playful gradient backdrop with warm highlights.

<Canvas of={VueHexStories.ThemeSunset} />

## Status bar layout

When `statusbar` is set to `"top"` or `"bottom"`, you can choose where each
status bar item renders by providing `statusbarLayout`. The status bar is split
into three sections:

- `left` (left-aligned)
- `middle` (centered)
- `right` (right-aligned)

Each section is an array of **status bar components**:

```ts
import type { VueHexStatusBarLayout } from "vuehex";

const layout: VueHexStatusBarLayout = {
  left: ["offset", "hex"],
  middle: ["ascii"],
  right: ["selection"],
};
```

Components can be provided as strings (component name) or as objects when you
also want to attach configuration:

```ts
const layout: VueHexStatusBarLayout = {
  left: [
    { name: "offset", config: { format: "hex", pad: 8 } },
    { name: "hex", config: { prefix: true } },
  ],
  middle: [{ name: "ascii", config: { quote: true } }],
  right: [
    { name: "selection", config: { label: "Sel", showWhenEmpty: false } },
  ],
};
```

Built-in component names:

- `offset`
- `hex`
- `ascii`
- `selection`
- `editable`
- `mode`
- `column`
- `total`
- `slot`

Notes:

- Unknown component names are ignored.
- When omitted, `statusbarLayout` defaults to `left: ["offset", "hex", "ascii"], right: ["selection"]`.
- Hover-driven items (`offset`, `hex`, `ascii`) reflect the cell under the mouse, not the keyboard cursor.
- Editor items (`editable`, `mode`, `column`) render whenever they are included in the layout (they do not auto-hide when `editable` is false).

### Custom slot components

Use the built-in `slot` component name to render your own custom content inside the status bar.

VueHex exposes three named slots:

- `#statusbar-left`
- `#statusbar-middle`
- `#statusbar-right`

To control where your slot content appears relative to built-in items, place `"slot"` in the corresponding `statusbarLayout` section:

```vue
<VueHex
  statusbar="bottom"
  :statusbar-layout="{ left: ['offset', 'slot', 'hex'], middle: ['ascii'], right: ['selection'] }"
  v-model="data"
>
  <template #statusbar-left>
    <span>Mode: RO</span>
  </template>
</VueHex>
```

### Label configuration

All built-in status bar components support overriding their label text via
`config.label`:

```ts
const layout: VueHexStatusBarLayout = {
  left: [
    { name: "offset", config: { label: "Addr" } },
    { name: "hex", config: { label: "Byte" } },
    { name: "ascii", config: { label: "Char" } },
  ],
  right: [{ name: "selection", config: { label: "Sel" } }],
};
```

### Supported config keys

- Common: `label`, `valueMinWidth` (CSS length), `valueWidth` (CSS length)
- `offset`: `format` ("hex" | "decimal"), `pad` (number), `prefix` (boolean)
- `hex`: `prefix` (boolean)
- `ascii`: `quote` (boolean)
- `selection`: `showWhenEmpty` (boolean)
- `editable`: `short` (boolean)
- `mode`: `short` (boolean), `placeholder` (string)
- `column`: `short` (boolean), `placeholder` (string)
- `total`: `format` ("human" | "hex"), `decimals` (number, for "human"), `unit` (boolean), `pad` (number, for "hex"), `prefix` (boolean, for "hex")

## Cursor

Enable the optional cursor to move around the dataset with the keyboard.

- Set the boolean `cursor` prop to enable the feature.
- Press arrow keys while the viewer is focused to move the cursor.
- Click any hex/ASCII byte to set the cursor.
- Use `v-model:cursorLocation` for two-way binding of the cursor position.
- The cursor location updates automatically as the user navigates.

```vue
<template>
  <VueHex
    v-model="data"
    cursor
    v-model:cursorLocation="cursorLocation"
    style="height: 320px"
  />
</template>

<script setup lang="ts">
import { ref } from "vue";
import VueHex from "vuehex";

const data = ref(new Uint8Array(1024));
const cursorLocation = ref<number | null>(0);

// cursorLocation automatically updates when the user moves the cursor
// You can also set it programmatically to move the cursor
watch(cursorLocation, (newLocation) => {
  console.log('Cursor moved to:', newLocation);
});
</script>
```

<Canvas of={VueHexStories.Cursor} />

## Custom themes

Target the emitted `.vuehex-theme-<token>` selector to ship your own art
direction. Attach a stylesheet near the story/component and redefine the CSS
custom properties VueHex consumes.

```ts
<template>
  <VueHex theme="storybook-custom" v-model="windowData" />
</template>

<style scoped src="./vuehex-custom-theme.css"></style>
```

Available CSS variables:

- `--vuehex-background`, `--vuehex-foreground`, `--vuehex-border-color`
- `--vuehex-offset-color`, `--vuehex-offset-leading-opacity`
- `--vuehex-row-divider`, `--vuehex-byte-color`
- `--vuehex-ascii-color`, `--vuehex-ascii-non-printable-color`
- `--vuehex-ascii-column-border`, `--vuehex-mid-column-gutter`

Structural selectors you can target:

```css
.vuehex-theme-your-token .vuehex-byte { /* hex column cells */ }
.vuehex-theme-your-token .vuehex-ascii-char { /* ASCII column */ }
.vuehex-theme-your-token .vuehex-byte.vuehex-linked-hover { /* shared hover */ }
.vuehex-theme-your-token .vuehex-ascii-char.vuehex-linked-hover { /* ASCII hover */ }
```

Pair those hooks with gradients, shadows, or data-URI textures to match your
brand. Because themes are only CSS, no recompilation is necessary--just load the
stylesheet next to your component.

<Canvas of={VueHexStories.CustomTheme} />
